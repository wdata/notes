# 重构：改善既有代码的设计（第二版）

## 第一章 重构，第一个示例

### 重构的步骤

1. 重构前保证有一套可靠的测试集，测试集必须有自我检验的能力；
2. **小步修改，每次修改后运行测试**；
3. 测试完成后，提交代码；
4. 再进行下一步的修改；

### 本次重构3个重要的节点

1. 将原函数分解成一组嵌套的函数；
2. 应用拆分阶段分离计算逻辑与输出格式化逻辑；
3. 为计算器引入多态性来处理计算逻辑；

### 运用到的方法

1. 提炼函数
2. 内联变量
3. 搬移函数
4. 以多态取代条件表达式

### 好代码的标准

好代码的检验标准就是**人们是否能轻而易举地修改它**。好代码应该直截了当：有人需要修改代码时，他们应能轻易找到修改点，应该能快速做出更改，而不易引入其他错误。

## 第二章 重构的原则

### 什么是重构

重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

重构的关键在于运用大量微小且保持软件行为的步骤，一步步达成大规模的修改。

### “两顶帽子”比喻

软件开发过程中，将时间分配给2种截然不同的行为：添加新功能和重构。2种行为不同时进行，行为完成后切换，像两顶帽子一样快速切换。

### 为何重构

1. 重构改进软件的设计
   1. 有助于代码维持该有的形态；
   2. 消除重复代码；
2. 重构使软件更容易理解
3. 重构帮助找到bug
4. 重构提高编程速度

### 何时重构

#### 三次法则

第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。

**事不过三，三则重构**;

#### 预备性重构：让添加新功能更容易

重构的最佳时机就在添加新功能之前

#### 帮助理解的重构：使代码更易懂

在研读代码时，重构会引领我获得更高层面的理解，如果只是阅读代码很难有此领悟。

#### 捡垃圾式重构

如果我发现的垃圾很容易重构，我会马上重构它；如果重构需要花一些精力，我可能会拿一张便笺纸把它记下来，完成当下的任务再回来重构它。

#### 有计划的重构和见机行事的重构

肮脏的代码必须重构，但漂亮的代码也需要很多重构。

种有计划的重构应该很少，大部分重构应该是不起眼的、见机行事的

#### 长期重构

如果想替换掉一个正在使用的库，可以先引入一层新的抽象，使其兼容新旧两个库的接口。一旦调用方已经完全改为使用这层抽象，替换下面的库就会容易得多。（这个策略叫作Branch By Abstraction[mf-bba]。）

#### 复审代码时重构

重构可以帮助我复审别人的代码

重构还可以帮助代码复审工作得到更具体的结果。不仅获得建议，而且其中许多建议能够立刻实现。最终你将从实践中得到比以往多得多的成就感。

#### 怎么对经理说

“重构”被视为一个脏词——经理（和客户）认为重构要么是在弥补过去犯下的错误，要么是不增加价值的无用功。

经理懂技术，能理解“设计耐久性假说”，那么向他说明重构的意义应该不会很困难

如果经理不懂技术，则可以尝试：不要告诉经理！

受进度驱动的经理要我尽可能快速完成任务，至于怎么完成，那就是我的事了。我领这份工资，是因为我擅长快速实现新功能；我认为最快的方式就是重构，所以我就重构。

#### 何时不应该重构

如果我看见一块凌乱的代码，但并不需要修改它，那么我就不需要重构它。

另一种情况是，如果重写比重构还容易，就别重构了。

### 重构带来的挑战

#### 延缓新功能开发

重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。

有一种情况确实需要权衡取舍。我有时会看到一个（大规模的）重构很有必要进行，而马上要添加的功能非常小，这时我会更愿意先把新功能加上，然后再做这次大规模重构。
如果一块代码我很少触碰，它不会经常给我带来麻烦，那么我就倾向于不去重构它。

如果你是一支团队的技术领导，一定要向团队成员表明，你重视改善代码库健康的价值。
合理判断何时应该重构、何时应该暂时不重构，这样的判断力需要多年经验积累。对于重构缺乏经验的年轻人需要有意的指导，才能帮助他们加速经验积累的过程。

**我们之所以重构，因为它能让我们更快——添加功能更快，修复bug更快。**

#### 代码所有权

比如我想给一个函数改名，如果我是这个函数所有者则很容易修改；如果是另一个团队拥有，没有写入权限，或者这是一个暴露给外部的API，无法知道有多少使用。
这样的函数属于已发布接口（published interface）：接口的使用者（客户端）与声明者彼此独立，声明者无权修改使用者的代码。
为了给一个函数改名，我需要使用函数改名，但同时也得保留原来的函数声明，使其把调用传递给新的函数，把旧接口标记为“不推荐使用”（deprecated）。

团队代码所有制：一支团队里的成员都可以修改这个团队拥有的代码，即便最初写代码的是别人。程序员可能各自分工负责系统的不同区域，但这种责任应该体现为监控自己责任区内发生的修改，而不是简单粗暴地禁止别人修改。

开源模型团队：跨团队的场合时，B团队的成员也可以在一个分支上修改A团队的代码，然后把提交发送给A团队去审核。

#### 分支

如果我修改了一个函数的名字，版本控制工具可以很轻松地将我的修改与Rachel的代码集成。但如果在集成之前，她在自己的分支里新添调用了这个被我改名的函数，集成之后的代码就会被破坏。

尽量缩短特性分支的生存周期

持续集成（Continuous Integration，CI），也叫“基于主干开发”（Trunk-Based Development）。在使用CI时，每个团队成员每天至少向主线集成一次。

特性开关（feature toggle，也叫特性旗标，feature flag）

#### 测试

不会改变程序可观察的行为，这是重构的一个重要特征。关键就在于“快速发现错误”。要做到这一点，我的代码应该有一套完备的测试套件，并且运行速度要快，否则我会不愿意频繁运行它。

方式：快速测试、自动化重构

新流派：只使用一组经过验证是安全的重构手法

#### 遗留代码

遗留代码往往很复杂，测试又不足，而且最关键的是，是别人写的（瑟瑟发抖）。

书：《修改代码的艺术》

#### 数据库

并行修改：

1. 要改名一个字段，会新添一个字段，但暂时不使用它。然后修改数据写入的逻辑，使其同时写入新旧两个字段。
2. 随后我就可以修改读取数据的地方，将它们逐个改为使用新字段。这
3. 步修改完成之后，我会暂停一小段时间，看看是否有bug冒出来。
4. 确定没有bug之后，我再删除已经没人使用的旧字段。

#### 重构、架构和YAGNI

重构对架构最大的影响在于，通过重构，我们能得到一个设计良好的代码库，使其能够优雅地应对不断变化的需求。

简单设计、增量式设计或者YAGNI[mf-yagni]——“你不会需要它”（you arenʼt going to need it）的缩写

1. 根据当前的需求来构造软件，同时把软件的设计质量做得很高;
2. 随着对用户需求的理解加深，我会对架构进行重构，使其能够应对新的需要。
3. 如果一种灵活性机制不会增加复杂度（比如添加几个命名良好的小函数），我可以很开心地引入它；
4. 如果一种灵活性会增加软件复杂度，就必须先证明自己值得被引入。
5. 要判断是否应该为未来的变化添加灵活性，我会评估“如果以后再重构有多困难”，只有当未来重构会很困难时，我才考虑现在就添加灵活性机制。我发现这是一个很有用的决策方法。

#### 重构与软件开发过程

重构起初是作为极限编程（XP）[mf-xp]的一部分被人们采用的，XP本身就融合了一组不太常见而又彼此关联的实践，例如持续集成、自测试代码以及重构（后两者融汇成了测试驱动开发）。

极限编程是最早的敏捷软件开发方法[mf-nm]之一。

重构的第一块基石是自测试代码，而且每个团队成员都需要掌握重构技能，能在需要时开展重构，CI则能帮助每个成员的重构都能快速分享给其他同事。
所以这三大实践——自测试代码、持续集成、重构——彼此之间有着很强的协同效应。

有这三大核心实践打下的基础，才谈得上运用敏捷思想的其他部分

#### 重构与性能

除了对性能有严格要求的实时系统，其他任何情况下“编写快速软件”的秘密就是：先写出可调优的软件，然后调优它以求获得足够的速度。

前2种方法：时间预算法（实时系统）、持续关注法（看起来有用，实际没用）

哪怕你完全了解系统，也请实际度量它的性能，不要臆测。

第三种性能提升法就是利用上述的90%统计数据，在性能优化阶段，首先应该用一个度量工具来监控程序的运行，让它告诉我程序中哪些地方大量消耗时间和空间。

我发现重构可以帮助我写出更快的软件。短期看来，重构的确可能使软件变慢，但它使优化阶段的软件性能调优更容易，最终还是会得到好的效果。

#### 重构起源何处

起源无从谈起，但在20世纪80年代，Smalltalk社区的Ward Cunningham和Kent Beck最早意识到重构的重要性。

#### 自动化重构

第一个自动化重构工具是Smalltalk的Refactoring Browser

大体有2种类型的自动化重构方法：1、文本操作；2、代码语法树操作；

#### 延伸阅读

重构练习：《重构手册》
