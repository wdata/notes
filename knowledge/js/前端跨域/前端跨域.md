## 前端跨域及其解决方案
<br />

#### <div id="1">什么是跨域</div>
广义跨域：指从一个域下的文档或脚本，试图去请求另一个域下的资源；
```
{
  1、资源跳转：a链接、重定向、表单提交；
  2、资源嵌入：<link>、<script>、<img>、<frame>等dom标签，还有样式中background: url()、@font-face()等文件外链；
  3、脚本请求：js发起的ajax请求、dom和js对象的跨域操作等；
}
```
狭义跨域：是由浏览器同源策略限制的一类请求场景；

#### <div id="2">同源策略</div>
同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。

同源：是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

```
{
  1、Cookie、LocalStorage 和 IndexDB 无法读取；
  2、DOM 和 js对象无法获得；
  3、AJAX 请求不能发送；
}
```

#### <div id="3">场景的跨域场景</div>
```
{
            URL                                说明                是否允许通信
  http://www.domain.com/a.js
  http://www.domain.com/b.js         同一域名，不同文件或路径           允许
  http://www.domain.com/lab/c.js

  http://www.domain.com:8000/a.js
  http://www.domain.com/b.js         同一域名，不同端口                不允许

  http://www.domain.com/a.js
  https://www.domain.com/b.js        同一域名，不同协议                不允许

  http://www.domain.com/a.js
  http://192.168.4.12/b.js           域名和域名对应相同ip              不允许

  http://www.domain.com/a.js
  http://x.domain.com/b.js           主域相同，子域不同                不允许
  http://domain.com/c.js

  http://www.domain1.com/a.js
  http://www.domain2.com/b.js        不同域名                         不允许
}
```

#### <div id="4">跨域的解决方案</div>

1、[通过jsonp跨域](#4_1)
2、[document.domain + iframe跨域](#4_2)
3、[location.hash + iframe](#4_3)
4、[window.name + iframe跨域](#4_4)
5、[postMessage跨域](#4_5)
6、[跨域资源共享（CORS）](#4_6)
7、[nginx代理跨域](#4_7)
8、[nodejs中间件代理跨域](#4_8)
9、[WebSocket协议跨域](#4_9)


#### <div id="4_1">一、通过jsonp跨域</div>
通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。

1、）原生实现：

```js
{
  <script>
    let script = document.createElement('script');
    script.type = 'text/jsvascript';

    // 传参并指定回调执行函数为onBack
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=onBack';
    document.head.appendChild(script);

    // 回调执行函数
    function onBack(res) {
      alert(JSON.stringify(res));
    }
  </script>
}
```

服务端返回如下（返回时即执行全局函数）：

```js
{
  onBack({"status": true, "user": "admin"})
}
```

2、）jquery ajax：

```js
{
  $.ajax({
    url: 'http://www.domain2.com:8080/login',
    type: 'get',
    dataType: 'jsonp', // 请求方式为jsonp
    jsonpCallback: 'onBack', // 自定义回调函数名
    data: {}
  });
}
```

3、）vue.js：

```js
{
  this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'onBack'
  }).then((res) => {
    console.log(res);
  });
}
```

后端node.js代码示例：

```js
{
  var querystring = require('querystring');
  var http = require('http');
  var server = http.createServer();

  server.on('request', function(req, res) {
      var params = qs.parse(req.url.split('?')[1]);
      var fn = params.callback;

      // jsonp返回设置
      res.writeHead(200, { 'Content-Type': 'text/javascript' });
      res.write(fn + '(' + JSON.stringify(params) + ')');

      res.end();
  });

  server.listen('8080');
  console.log('Server is running at port 8080...');
}
```

**jsonp缺点：只能实现get一种请求**。


#### <div id="4_2">二、document.domain + iframe跨域</div>
**此方案仅限主域相同，子域不同的跨域应用场景**。

实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

1.）父窗口：(http://www.domain.com/a.html)
```js
{
  <iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
  <script>
    document.domain = 'domain.com';
    var user = 'admin';
  </script>
}
```

2.）子窗口：(http://child.domain.com/b.html)
```js
{
  document.domain = 'domain.com';
  // 获取父窗口的变量
  alert('get js data from parent ---> ' + window.parent.user);
}
```
