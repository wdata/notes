### 字符串的扩展

学习和引用自[ECMAScript 6 入门 - 作者：阮一峰](http://es6.ruanyifeng.com/#docs/destructuring)
* [1、字符的 Unicode 表示法](#1)
  - 1、JavaScript 允许采用<span style="color: red;">\uxxxx</span>形式表示一个字符，其中<span style="color: red;">xxxx</span>表示字符的 <span style="color: red;">Unicode</span>码点；
  - 2、限制：这种表示法只限于码点在<span style="color: red;">\u0000~\uFFFF</span>之间的字符；超出这个范围的字符，必须用两个双字节的形式表示；
  - 3、ES6写法：将<span style="color: #a6e22e;">马点</span>放入大括号中（例：<span style="color: red;">'\u{41}'</span>）：
* [2、codePointAt()](#2)
  - 1、JavaScript内部，字符以 UTF-16 的格式储存，每个字符固定为<span style="color: red;">2</span>个字节；
  - 2、Unicode码点大于<span style="color: red;">0xFFFF</span>的字符需要<span style="color: red;">2</span>个字符或<span style="color: red;">4</span>个字节存储；
  - 3、JavaScript不能正确处理<span style="color: red;">2</span>个字符的码点，字符串长度会误判为<span style="color: red;">2</span>;
  - 4、<span style="color: red;">charAt</span>、<span style="color: red;">charCodeAt</span>、<span style="color: red;">codePointAt</span>的不同点和优点：
    - 1、<span style="color: red;">charAt</span>方法无法读取整个字符；
    - 2、<span style="color: red;">charCodeAt</span>方法只能分别返回前两个字节和后两个字节的值
    - 3、<span style="color: red;">codePointAt</span>方法，能够正确处理<span style="color: red;">4</span>个字节储存的字符，返回32位的 UTF-16 字符的码点，为十进制值；
  - 5、<span style="color: red;">toString</span>可转化<span style="color: red;">codePointAt</span>返回为进制为十六进制；
  - 6、<span style="color: red;">codePointAt</span>使用<span style="color: red;">for...of</span>循环，会正确识别 32 位的 UTF-16 字符；
  - 7、<span style="color: red;">codePointAt</span>方法是测试一个字符由两个字节还是由四个字节组成的最简单方法；
* [3、String.fromCodePoint()](#3)
  - 1、ES5方法：<span style="color: red;">String.fromCharCode</span>，用于从码点返回对应字符，但是这个方法不能识别<span style="color: red;">32</span>位的UTF-16字符（Unicode编号大于<span style="color: red;">0xFFFF</span>）
  - 2、ES6方法：<span style="color: red;">String.fromCodePoint</span>能识别<span style="color: red;">32</span>位的UTF-16字符以上的字符串；
* [4、字符串的遍历器接口](#4)
  - 1、ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被<span style="color: red;">for...of</span>循环遍历；
  - 2、能识别<span style="color: red;">0xFFFF</span>等码点；
* [5、字符串的遍历器接口](#5)
  - 1、<span style="color: red;">normalize</span>方法可以接受一个参数来指定<span style="color: red;">normalize</span>的方式，参数的四个可选值如下：
    - <span style="color: red;">NFC</span>，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。
    - <span style="color: red;">NFD</span>，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。
    - <span style="color: red;">NFKC</span>，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，<span style="color: red;">normalize</span>方法不能识别中文。）
    - <span style="color: red;">NFKD</span>，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。
  - 2、<span style="color: red;">normalize</span>方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。





### <div id="1">1、字符的Unicode表示法</div>
* 1、JavaScript 允许采用<span style="color: red;">\uxxxx</span>形式表示一个字符，其中<span style="color: red;">xxxx</span>表示字符的 <span style="color: red;">Unicode</span>码点；
  ```
  {
    "\u0061"
    // "a"
  }
  ```
* 2、限制：这种表示法只限于码点在<span style="color: red;">\u0000~\uFFFF</span>之间的字符；超出这个范围的字符，必须用两个双字节的形式表示；
  ```
  {
    "\uD842\uDFB7"
    // "𠮷"

    "\u20BB7"
    // " 7"
  }
  ```
  上面代码表示，如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。

* 3、ES6写法：将<span style="color: #a6e22e;">马点</span>放入大括号中：
  ```
  {
    1、最基础写法：
    "\u{20BB7}"
    // "𠮷"

    2、多字节写法：
    "\u{41}\u{42}\u{43}"
    // "ABC"

    3、可用Unicode写变量：
    let hello = 123;
    hell\u{6F} // 123

    4、ES6写法与原始写法相等：
    '\u{1F680}' === '\uD83D\uDE80'
    // true
  }
  ```
* JavaScript 共有 6 种方法可以表示一个字符：
  ```
  {
    '\z' === 'z'  // true
    '\172' === 'z' // true
    '\x7A' === 'z' // true
    '\u007A' === 'z' // true
    '\u{7A}' === 'z' // true
  }
  ```

### <div id="2">2、codePointAt()</div>
* 1、JavaScript内部，字符以 UTF-16 的格式储存，每个字符固定为<span style="color: red;">2</span>个字节。
  ```
  {
    var s = "𠮷";

    s.length // 2
    s.charAt(0) // ''
    s.charAt(1) // ''
    s.charCodeAt(0) // 55362
    s.charCodeAt(1) // 57271
  }
  ```
* 2、Unicode码点大于<span style="color: red;">0xFFFF</span>的字符需要<span style="color: red;">2</span>个字符或<span style="color: red;">4</span>个字节存储；
* 3、JavaScript不能正确处理<span style="color: red;">2</span>个字符的码点，字符串长度会误判为<span style="color: red;">2</span>;
* 4、<span style="color: red;">charAt</span>、<span style="color: red;">charCodeAt</span>、<span style="color: red;">codePointAt</span>的不同点和优点：
  - 1、<span style="color: red;">charAt</span>方法无法读取整个字符；
  - 2、<span style="color: red;">charCodeAt</span>方法只能分别返回前两个字节和后两个字节的值
  - 3、<span style="color: red;">codePointAt</span>方法，能够正确处理<span style="color: red;">4</span>个字节储存的字符，返回32位的 UTF-16 字符的码点，为十进制值；
  ```
  {
    let s = '𠮷a';

    s.codePointAt(0) // 134071
    s.codePointAt(1) // 57271

    s.codePointAt(2) // 97
  }
  ```
* 5、<span style="color: red;">toString</span>可转化<span style="color: red;">codePointAt</span>返回为进制为十六进制；
  ```
  {
    let s = '𠮷a';

    s.codePointAt(0).toString(16) // "20bb7"
    s.codePointAt(2).toString(16) // "61"
  }
  ```
* 6、<span style="color: red;">codePointAt</span>使用<span style="color: red;">for...of</span>循环，会正确识别 32 位的 UTF-16 字符；
  ```
  {
    let s = '𠮷a';
    for (let ch of s) {
      console.log(ch.codePointAt(0).toString(16));
    }
    // 20bb7
    // 61
  }
  ```
* 7、<span style="color: red;">codePointAt</span>方法是测试一个字符由两个字节还是由四个字节组成的最简单方法；
  ```
  {
    function is32Bit(c) {
      return c.codePointAt(0) > 0xFFFF;
    }

    is32Bit("𠮷") // true
    is32Bit("a") // false
  }
  ```
### <div id="3">3、String.fromCodePoint()</div>
* 1、ES5方法：<span style="color: red;">String.fromCharCode</span>，用于从码点返回对应字符，但是这个方法不能识别<span style="color: red;">32</span>位的UTF-16字符（Unicode编号大于<span style="color: red;">0xFFFF</span>）
  ```
  {
    String.fromCharCode(0x20BB7)
    // "ஷ"
    // String.fromCharCode不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符
  }
  ```
* 2、ES6方法：<span style="color: red;">String.fromCodePoint</span>能识别<span style="color: red;">32</span>位的UTF-16字符以上的字符串；
  ```
  {
    String.fromCodePoint(0x20BB7)
    // "𠮷"
    String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'
    // true
    // 如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回
  }
  ```

### <div id="4">4、字符串的遍历器接口</div>
* 1、ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被<span style="color: red;">for...of</span>循环遍历；
  ```
  {
    for (let codePoint of 'foo') {
      console.log(codePoint)
    }
    // "f"
    // "o"
    // "o"
  }
  ```
* 2、能识别<span style="color: red;">0xFFFF</span>等码点；
  ```
  {
    let text = String.fromCodePoint(0x20BB7);

    for (let i = 0; i < text.length; i++) {
      console.log(text[i]);
    }
    // �
    // �

    for (let i of text) {
      console.log(i);
    }
    // "𠮷"
  }
  ```
### <div id="5">5、字符串的遍历器接口</div>
ES5的缺陷：
```
{
  '\u01D1'==='\u004F\u030C' //false

  '\u01D1'.length // 1
  '\u004F\u030C'.length // 2
}
```
ES6提供<span style="color: red;">normalize()</span>用来将字符的不同表示方法统一为同样的形式，这称为<span style="color: #a6e22e;">Unicode正规化</span>;
```
{
  '\u01D1'.normalize() === '\u004F\u030C'.normalize()
  // true
}
```
* 1、<span style="color: red;">normalize</span>方法可以接受一个参数来指定<span style="color: red;">normalize</span>的方式，参数的四个可选值如下：
  - <span style="color: red;">NFC</span>，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。
  - <span style="color: red;">NFD</span>，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。
  - <span style="color: red;">NFKC</span>，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，<span style="color: red;">normalize</span>方法不能识别中文。）
  - <span style="color: red;">NFKD</span>，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。

* 2、<span style="color: red;">normalize</span>方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。
