## 变量的解构赋值

学习和引用自[ECMAScript 6 入门 - 作者：阮一峰](http://es6.ruanyifeng.com/#docs/destructuring)

* [数组的解构赋值](#1)
  - [基本用法](#1_1)
  - [默认值](#1_2)
* [对象的解构赋值](#2)
  - [与数组解构赋值的不同点](#2_1)
  - [对象解构赋值的特点](#2_2)

### <div id="1">1.数组的解构赋值</div>
#### <div id="1_1">1.1 基本用法</div>
ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构

```
{
  let a = 1;
  let b = 2;
  let c = 3;

  // ES6写法：
  let [a, b, c] = [1, 2, 3];
}
```
* 本质为“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值;
* 1、解构不成功，值会等于<span style="color: red;">undefined</span>;
  ```
  {
    let [foo] = [];
    let [bar, foo] = [1];
    // foo = undefined;
  }
  ```
* 2、不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组；
  ```
  {
    let [x, y] = [1, 2, 3];
    // x = 1 y = 2
  }
  ```
* 右边数据解构必须具有 Iterator 接口，否则会报错；
  ```
  {
    // 报错
    let [foo] = 1;
    let [foo] = false;
    let [foo] = NaN;
    let [foo] = undefined;
    let [foo] = null;
    let [foo] = {};

    // 数据解构具有iterator接口
    function* fibs() {
      let a = 0;
      let b = 1;
      while (true) {
        yield a;
        [a, b] = [b, a + b];
      }
    }

    let [first, second, third, fourth, fifth, sixth] = fibs();
    sixth // 5

    遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。
    任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。
  }
  ```

#### <div id="1_2">1.2 默认值</div>
解构赋值允许指定默认值
```
{
  let [foo = true] = [];
  foo // true
}
```
* 如果右侧对应成员是<span style="color: red;">null</span>，则默认值就不会生效；
  ```
  {
    let [x = 1] = [null];
    x // null
  }
  ```
* 如果右侧对应成员是<span style="color: red;">undefined</span>，则执行解构赋值默认值；
  ```
  {
    function f() {
      console.log('aaa');
    }
    let [x = f()] = [1];

    // 等价于下面的表达式
    let x;
    if ([1][0] === undefined) {
      x = f();
    } else {
      x = [1][0];
    }
  }
  ```
### <div id="2">2. 对象的解构赋值</div>
```
{
  let { foo, bar } = { foo: "aaa", bar: "bbb" };
  foo // "aaa"
  bar // "bbb"
}
```
#### <div id="2_1">2.1 与数组解构赋值的不同点</div>
数组的元素是<span style="color: #a6e22e;">按次序排列的</span>，变量的取值由它的位置决定；而对象的属性<span style="color: #a6e22e;">没有次序</span>，变量必须与属性同名，才能取到正确的值。
```
{
  let { bar, foo } = { foo: "aaa", bar: "bbb" };
  foo // "aaa" bar // "bbb"
}
```

#### <div id="2_2">2.2 对象解构赋值的特点</div>
* 1、如果没有对应的同名属性，则等于<span style="color: red;">undefined</span>；
  ```
  {
    // 没有同名属性，返回undefined
    let { baz } = { foo: "aaa", bar: "bbb" };
    baz // undefined
  }
  ```
* 2、对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量，真正被赋值的是后者（<span style="color: #a6e22e;">变量</span>），而不是前者（<span style="color: #a6e22e;">模式</span>）；
  ```
  {
    let { foo: baz } = { foo: "aaa", bar: "bbb" };
    baz // "aaa"
    foo // error: foo is not defined

    //foo是模式，baz才是变量
  }
  ```
  ```
  {
    const node = {
      loc: {
        start: {
          line: 1,
          column: 5
        }
      }
    };

    let { loc, loc: { start }, loc: { start: { line }} } = node;
    line // 1
    loc  // Object {start: Object}
    start // Object {line: 1, column: 5}

    // 第一个loc是变量，后两个loc是模式
  }
  ```
* 3、对象解构赋值默认值生效的条件是，对象的属性值严格等于<span style="color: red;">undefined</span>；
  ```
  {
    let {x = 3} = {x: undefined};
    x // 3

    let {x, y = 5} = {x: 1};
    x // 1
    y // 5

    // 属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值
    var {x = 3} = {x: null};
    x // null
  }
  ```
* 4、如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错；
  ```
  {
    let {foo: {bar}} = {baz: 'baz'};
    // 因为foo这时等于undefined，再取子属性就会报错
    // 类似于
    let _tmp = {baz: 'baz'}
    _tmp.foo.baz // 报错
  }
  ```
* 5、不能单独写<span style="color: red;">{x}={x:1}</span>，要么前面加<span style="color: red;">let、const、var</span>执行对象解构赋值就会报错，或者用<span style="color: red;">({x}={x:1})</span>包裹代码块；
  ```
  {
    // 错误的写法
    let x;
    {x} = {x: 1};
    // SyntaxError: syntax error

    // 正确的写法
    let x;
    ({x} = {x: 1});
  }
  ```
* 6、由于数组质是特殊的对象，因此可以对数组进行对象属性的解构，<span style="color: #a6e22e;">为属性名表达式</span>；
  ```
  {
    let arr = [1, 2, 3];
    let {0 : first, [arr.length - 1] : last} = arr;
    first // 1
    last // 3
  }
  ```
